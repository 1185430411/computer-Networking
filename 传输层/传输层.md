# TCP与UDP的特点与区别
## UDP（用户数据包协议）是无连接的，尽最大可能交付（即不可靠传输），没有拥塞控制，面向报文（对于应用程序传下俩的报文即不合并也不拆分，仅仅添加UDP首部），支持一对一，一对多，多对一，多对多的交互通信。
## TCP（传输控制协议）是面向连接的，有流量控制，拥塞控制，提供可靠支付，提供全双工通信，面向字节流（对应用层传下来的报文看作是字节流，把字节流组织成大小不等的1数据块），每一条TCP连接只能是点对点的（一对一）。

# UDP首部格式
## 首部只有8个字节，4个字段，分别是源端口，目的端口，长度，检验和，12个字节的伪首部是为了计算检验和临时加上的。

# TCP首部格式
## 序号：
用来对字节流进行编号。例如序号为301，表示第一个字节的编号是301，如果数据长度为100，则下一个报文段的序号是401.
## 确认号：
表示期望收到的下一个报文段序号。若B收到A一个序号为501的报文段，数据长度为200，则B期望下一个希望收到的报文段序号为701，则确认号为701.
## 数据偏移：
记录数据部分距离报文段开头的距离，即首部的长度。
## 确认ACK：
当ACK为1时，报文段才有效，当TCP连接建立后，两个点之间传输的报文段中ACK必须是1.（区别于确认号。确认号是ack，指下一个期望收到的报文段开头。而ACK的内容只有1或0）
## 同步SYN：
在连接建立时的一个同步序列号。SYN=1，ACK=0的报文段为请求连接报文段。若对方同意连接，则发回一个SYN=1，ACK=1的报文段
## 终止FIN:
在请求释放连接时使用FIN。当发送FIN=1的报文段时，即表示数据传输完毕，请求释放连接。
## 窗口：
窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

# TCP三次握手
## 过程：（设A为客户端，B为服务器）
1.首先B出于LISTEN状态，等待A的连接请求。
2.A向B发出一个报文段，请求连接。SYN=1，ACK=0，选一个初始的序号x。
3.B收到A的请求报文，若同意连接，发送一个SYN=1，ACK=1，确认号为x+1，并选一个序号y。
4.A收到B的确认报文后，发送一个ACK=1，确认号为y+1,序号为x+1

## 三次握手的原因
1.防止在网络中滞留的请求连接报文段到达服务器，使服务器直接错误打开连接
2.客户端发送的请求连接报文在网络中滞留，客户端A在等待一个超时重传周期后，重新发送一个请求连接报文并成功建立连接，若此时在网络中滞留的第一个报文到达服务器B，此时B就会打开两个连接，造成浪费。若有第三次握手，客户端A收到第二个确认报文后不予理睬，不进行第三次握手，则B也不会建立连接造成资源浪费。

# TCP四次握手
## 过程：
1.客户端A想要释放连接，发送报文FIN=1.
2.服务器B发回确认报文ACK=1，此时TCP属于半关闭状态，只能B向A发送报文，A无法向B发送报文。
3.当B发送完所有数据后，发送连接释放报文FIN=1，ACK=1.
4.A收到后，发送确认，进入TIME-WAIT状态，等待2MSL（最大报文存活时间）后释放连接。
5。B收到A的确认后释放连接。
## 四次握手的原因
1.客户端发送FIN报文，服务器收到FIN报文，进入CLOSE-WAIT状态，这是为了让服务器发送还没发送完的数据。

2.客户端发送一个FIN=1，ACK=1报文段后，等待一个时间计时器2MSL，而不是直接进入CLOSE状态。这是为了防止客户端A直接关闭，而B因为某种原因没有接受到A的报文，一直无法关机造成浪费。

3.等待一段时间是为了让此次连接的所有报文在网络种消失，防止关机后又受到旧报文导致开机。

# TCP可靠传输
TCP的可靠传输利用超时重传机制实现，若一个报文在规定时间内没有得到确认，则重传该报文，一个报文段从发送到接到确认的往返时间为RTT，加权平均往返时间RTTS计算公式为：
                   RTTS=（1-a）RTTS+RTT

规定超时时间应该略大于RTTS，RTO计算公式为：
                   RTO=RTTS+4*RTTD
RTTD为偏差的加权平均值。

# TCP滑动窗口
窗口是缓存的一部分，用来暂时存放字节流，发送方和接收方都各有窗口，接收方通过TCP报文的窗口字段告诉发送方自己的窗口大小，从而让发送方调节自己的窗口大小。

发送窗口内的字节都允许被发送，接受窗口内的字节都允许被接受。若发送窗口左部的字节都已经发送并且收到了确认，则发送窗口右移，直到左边第一个字节没有被发送且确认接收。同理，接受窗口左边的字节若都已经接受并发送确认交付主机，则接收窗口向右移。

接收窗口只会对最后一个有序到达的字节发送接收成功的确认。即若收到了{2，3，5，8}。则接收端会发送3的确认交付主机，表示3之前的字节都已经成功接收。

# TCP流量控制
流量控制是为了让接收方控制发送方的发送速率，确保能来得及接收。
接收方发送TCP报文，窗口字段存着接收窗口的大小，从而来控制发送窗口的大小。

# TCP拥塞控制
如果网路堵塞，分组就会丢失，如果此时重发分组，就会使网络更加堵塞。这时就需要控制发送方的发送速率。（这点与流量控制很相似，但目的不同。流量控制是为了使接受方来得及接收，但拥塞控制是为了降低网络中的堵塞）

TCP主要通过四个算法来进行拥塞控制：慢开始，拥塞避免，快开始，快恢复。
在讨论这几个算法之前，先说明几个变量。拥塞窗口（cwnd）：即表示发送方每次发送多少数据。        慢开始门限（ssthresh）：当超过此值之后，慢开始变为拥塞避免。


### 1.慢开始与拥塞避免。
首先设置一个慢开始门限（ssthresh）。一开始时，cwnd设为1，也就是第一次发送一个报文段，若得到确认，cwnd*=2，也就是下一次发送2个报文段，若再次得到确认，则在翻倍.....直到cwnd>=ssthresh时，开始拥塞避免算法，每次只令cwnd+1，当出现超时情况时，ssthresh设为 cwnd/2，并把cwnd归为1，重新进行慢开始。

### 2.快开始与快恢复
在接收方，每次都对接收到到的最后一个有序报文段进行却确认，如收到了{1，2，4，5，6}，则会发出4个2的确认（2，4，5，6分别一次）。此时若发送方连续收到了3次对于一个报文段的重复确认，则可以断定该报文段的下一个报文段在网络中丢失（比如3），而不是因为网络拥塞，此时就进行快恢复。  即令ssthresh=cwnd，而直接令cwnd=ssthresh（而在慢开始算法中，cwnd直接被置为1）.这就是“快”与“慢”的意思









